multi sw 0 5 stack 
 lw 0 2 inputA # $2 = memory[inputC] as multicand
 lw 0 3 inputX      # $3 = memory[inputP] as multiplier
 lw 0 4 pos1        # $4 = 1 temporary control
 lw 0 6 neg1        # $6 = -1 temporary counter
 lw 0 7 pos15       # $7 = 15 constant
 add 0 0 1          # set reg1=0 
loop nand 3 4 5     # keep nand value between mplier and temp into $5
 nand 5 5 5         # change nand-gate to and-gate
 beq 0 5 shift      # if value from $5 is equal 0 then go to shift
 add 2 1 1          # else add mplier to product  
shift add 2 2 2     # shift left mcand by adding mcand
 add 4 4 4          # shift left temp by adding temp
 add 6 7 7          # $7 -= 1 
 beq 0 7 start       # is $7 == 0? if false go to loop
 beq 0 0 loop       #jump to loop
 noop
start lw 0 5 stack
 lw 0 2 inputB      #load inputB to reg 2
 add 1 2 1          #AX + B
 lw 0 3 pos1        #load 1 to reg 3
 add 3 5 5          #sp = sp+1
 sw 5 1 stack       #store AX+B to next stack(sp+1) 
 lw 0 2 inputX      #load X to reg 2 
 add 2 3 2          #x=x+1
 sw 0 2 inputX      #store x=x+1 to inputX
 lw 0 3 inputA           #load A to reg 3
 lw 0 4 inputZ           #load Z to ref 4
 lw 0 7 pos1        #load 1 to reg 7
 add 4 7 4          #z=z+1
 beq 2 4 done       #check if(x==z) halt;
 jalr 0 1           #else jump to multi
done halt
pos1 .fill 1
pos15 .fill 15
neg1 .fill -1
inputA .fill 2      # A = 2
inputX .fill 1      # X start at 1
inputB .fill 3      # B = 3
inputZ .fill 3      # Z = 3
stack .fill 0       # beginning of stack (value is irrelevent)
 .fill 0
 .fill 0
 .fill 0
 .fill 0
 .fill 0
 .fill 0
 .fill 0
 .fill 0
 .fill 0
 .fill 0